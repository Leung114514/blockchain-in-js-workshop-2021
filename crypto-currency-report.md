# 数字货币技术理论课实验报告

## 小组成员

- 2021131137 耿翔宇（组长）
- 2021131138 刘骐宁
- 2021131139 徐睿骐
- 2021131140 曹梁


## 代码仓库链接
https://github.com/Leung114514/blockchain-in-js-workshop-2021



## 第一课代码


### 代码 commint 地址
https://github.com/CUITBlockchain/blockchain-in-js-workshop-2021/commit/02778537f420324a8b1f06035d0836b5d096cc25

### 代码截图

> 将截图上传至网盘，放入链接即可

链接：https://pan.baidu.com/s/18kHmcwqCN_T8hLGMxVpW2Q?pwd=45le 
提取码：45le


### 主观与讨论题内容

---
### hash函数是怎么实现的
在Merkle树中，哈希函数通常使用加密哈希函数，例如SHA-256。这种哈希函数能够将一个任意长度的消息压缩成一个固定长度的摘要或哈希值，并且对于不同的输入，几乎总是产生不同的输出。

在构建Merkle树时，每个叶子节点都包含一个数据块的哈希值。这些哈希值被逐层合并成树状结构，直到最终形成一个根哈希值，也称为Merkle根。每个父节点的哈希值是其两个子节点的哈希值的组合，这样从叶子节点到根节点的每一级都包含了哈希值的组合。

例如，在比特币中，区块链使用Merkle树来存储所有交易的哈希值。每个区块包含多个交易，其中每个交易的哈希值都位于叶子节点上。这些哈希值然后按照一定的顺序进行配对和哈希，直到最终形成一个Merkle根。通过验证Merkle根，可以有效地验证整个区块链的完整性，因为如果任何交易发生更改，那么Merkle根也会随之更改，这就使得数据篡改变得非常困难。


### 怎么删除和添加节点
在Merkle树中，添加和删除节点的过程比较简单，但需要重新计算整个树结构。这是由于每个节点的哈希值取决于其子节点的哈希值，因此更改任何一个节点的值都会影响到上面的所有节点。

对于添加节点，可以将新节点插入到叶子层，并逐层向上更新父节点的哈希值。例如，在比特币中，当有新交易时，可以将其哈希值插入到Merkle树的最低层，并通过逐级组合和哈希操作来计算新的Merkle根。

对于删除节点，则需要从叶子节点开始向上移除节点，并更新其父节点的哈希值。如果删除的节点是某个父节点的唯一子节点，则该父节点也需要被删除，并依次向上进行调整。

需要注意的是，为了避免出现数据不一致的情况，Merkle树的添加和删除操作通常会在批量处理中进行，而不是单个节点的添加或删除。这样可以减少计算量，并确保在任何时候，Merkle树始终与底层数据的完整性相匹配。

### 验证函数的实现
在Merkle树中，验证函数的实现非常简单。验证函数的目的是检查给定数据是否属于Merkle树，并检查Merkle树的完整性。

验证函数的步骤如下：

1. 获取要验证的数据块的哈希值。
2. 从Merkle树的底部开始向上遍历，找到包含该哈希值的叶子节点。
3. 沿着路径向上遍历到根节点，并逐级计算与路径上其他节点哈希值的组合结果，直到达到根节点。
4. 检查计算出的根哈希值是否与Merkle树的根哈希值相同。

如果计算出的根哈希值与Merkle树的根哈希值相同，则说明该数据属于Merkle树，并且Merkle树的完整性得到了验证。否则，就说明该数据不属于Merkle树或者Merkle树的完整性已经被破坏。

需要注意的是，为了避免出现篡改数据的情况，验证函数应该使用公开的Merkle根哈希值来进行验证，而不是直接从Merkle树中获取根哈希值。这样可以确保任何人都可以验证数据的完整性，并防止恶意方尝试篡改Merkle树以隐藏其行为

---
## 第二课代码


### 代码 commint 地址

https://github.com/CUITBlockchain/blockchain-in-js-workshop-2021/commit/25f3a0d83a9fff2b4514c5503f470df939d0c2af


### 代码截图

> 将截图上传至网盘，放入链接即可

![](链接)


### 主观与讨论题内容

---
#### 字典树优缺点
字典树（Trie树）是一种用于字符串查找的数据结构，它的优点和缺点如下：
优点：
1.搜索字符串的时间复杂度与字符串长度无关，只与字符串的数量相关，搜索效率非常高。
2.可以方便地实现字符串的前缀匹配，即查找以某个字符串为前缀的所有字符串。
3.可以应用于字符串排序和统计，具有较高的灵活性和可扩展性。
4.实现简单，易于理解和操作。
缺点：
1.对于大量重复的字符串，会浪费大量的存储空间，且内存访问不连续，性能较差。
2.构建字典树的时间复杂度较高，需要遍历所有字符串并插入每个字符，时间复杂度为 O(nm)，其中 n 是字符串数量，m 是字符串的平均长度。
3.在最坏情况下，即所有字符串的公共前缀长度很长时，字典树的深度会变得很大，会造成搜索效率的降低。
4.当字符串集合动态变化时，需要频繁地重建整个字典树，操作复杂度较高。
综上所述，字典树主要适用于大量字符串的匹配和查找，具有高效的搜索效率和灵活的字符操作能力，但也存在较大的空间浪费和构建时间较长的缺点，因此应根据实际情况进行选择。
#### 如何扩展和优化字典树数据结构
字典树是一个非常有用的数据结构，可以用于字符串的匹配和查找。为了更好地利用字典树，可以使用以下方法来扩展和优化它：
1. 压缩字典树（Compressed Trie）：对于具有许多从根节点到某个叶子节点相同前缀的字典树，可以通过将这些相同前缀压缩为一个节点来减小字典树的规模，从而减少存储空间和构建时间。压缩字典树的查询效率和标准字典树相同。
2. 双向字典树（Bidirectional Trie）：标准的字典树只能在一侧进行深度优先搜索，效率较低，而双向字典树可以同时从根节点和叶子节点进行搜索，速度更快。
3. 基数树（Radix Tree）：在字典树中，每个节点包含一个字符或者字符编号，因此需要占用大量空间。而基数树将多个字符或编号组成的字符串作为一个节点处理，从而减少了空间开销。
4. 带权字典树（Ternary Search Tree）：对于需要从多个字符串中查找某个最长公共前缀或者查找最接近的字符串的情况，可以使用带权字典树，每个节点保存该节点所代表的字符串的权重值，在查找时根据权重值确定下一步的搜索方向。
5. 使用缓存：对于使用字典树的一些应用程序，建立字典树的过程比较耗时，可以使用缓存，将构建好的字典树缓存起来，加快查询速度。
总之，扩展和优化字典树数据结构可以提高查询和存储效率，从而使得字典树可以更广泛地应用于实际情况。




## 第三课代码


### 代码 commint 地址

https://github.com/CUITBlockchain/blockchain-in-js-workshop-2021/commit/25f3a0d83a9fff2b4514c5503f470df939d0c2af


### 代码截图

> 将截图上传至网盘，放入链接即可

![](链接)


### 主观与讨论题内容
---
#### 基于字典树，以太坊做了哪些改良，为什么？
以太坊并没有直接基于字典树做出改良，而是使用了一种名为"默克尔树"的数据结构来优化账户状态的存储和管理。

在以太坊中，每个区块中都包含着一组交易，这些交易会改变账户的状态。由于账户状态的改变较为频繁，如果将所有账户状态都存储在一个大的数据库中，查询和更新效率都会比较低。因此，以太坊采用了一种类似于内存数据库的设计，将账户状态存储在内存中，并定期将其持久化到硬盘上。

其中，默克尔树就是用来优化账户状态存储和管理的重要工具。它可以将账户状态按照某种方式进行划分，并组织成一棵树形结构，从而实现快速查找、验证和更新账户状态。

具体来说，在以太坊中，每个区块的头部都包含着一颗默克尔树的根节点哈希值。这个哈希值是由该区块中所有交易所引起的状态变化计算得出的。当一个交易被提交到以太坊网络中时，节点会根据这个交易对应的默克尔树叶子节点的哈希值，逐级向上计算出新的根节点哈希值，并将其广播给其他节点。这样，所有节点就能够共同维护账户状态，并快速验证和更新状态的变化。

总之，以太坊使用默克尔树来优化账户状态的存储和管理，从而实现快速查找、验证和更新账户状态。相对于传统的数据库存储方式，这种设计可以更加高效地管理大量的账户状态信息。

---
#### MPT想要解决的核心问题是什么？

MPT的核心问题是如何实现高效的、安全的数据存储和检索。

在区块链中，MPT被用来存储所有交易和账户信息，并且通过将不同的账户和交易分到不同的子树中，可以实现高效的数据管理和检索。具体来说，MPT使用Trie数据结构来存储键值对，其中每个键值对都代表一个唯一的合约地址或账户地址。与传统的Trie不同的是，MPT在内部节点上使用了Merkle哈希来增强数据的安全性和完整性。

通过使用这种数据结构，MPT可以快速地检索特定的账户信息和交易记录，并且还可以防止数据被篡改。因此，在区块链中，MPT被广泛应用于存储和管理交易和账户信息，以保证整个系统的安全性和有效性。

---

